#ifndef ENABLE_NORMAL_NORMALIZATION
  #define ENABLE_NORMAL_NORMALIZATION 1
#endif

#ifndef ENABLE_BRUSH
  #define ENABLE_BRUSH 1
#endif

#ifndef ENABLE_CIRCULAR_BRUSH
  #define ENABLE_CIRCULAR_BRUSH 0
#endif

#ifndef LIGHTS_COUNT
  #define LIGHTS_COUNT 6
#endif

precision highp float;

uniform highp vec3 ScreenFrontDirection;
uniform highp vec3 ScreenUpDirection;
uniform highp vec3 ScreenRightDirection;

uniform vec3 LightDirections[LIGHTS_COUNT];
uniform vec3 LightReflectionDirections[LIGHTS_COUNT]; // 2x closer to each other
uniform vec3 LightColors[LIGHTS_COUNT];

uniform sampler2D BaseColor;
uniform sampler2D ReflectionsColor;
uniform sampler2D Normal;
uniform sampler2D Shininess;
#if ENABLE_BRUSH && !ENABLE_CIRCULAR_BRUSH
    uniform sampler2D Brush;
#endif

varying vec2 UV;
varying vec3 FOVNormal;

void main()
{
    // tex values
    vec3 base_color = texture2D(BaseColor, UV).xyz;
    vec3 reflections_color = texture2D(ReflectionsColor, UV).xyz;

    vec3 normal = texture2D(Normal, UV).xyz * 2.0 - 1.0;
    if (abs(normal.x) < 0.01) normal.x = 0.0;
    if (abs(normal.y) < 0.01) normal.y = 0.0;
    if (abs(normal.z) < 0.01) normal.z = 0.0;
#if ENABLE_NORMAL_NORMALIZATION
    normal = normalize(normal);
#endif

    float shininess = texture2D(Shininess, UV).x;

#if ENABLE_BRUSH
  #if !ENABLE_CIRCULAR_BRUSH
    vec3 brush = texture2D(Brush, UV).xyz * 2.0 - 1.0;
    if (abs(brush.x) < 0.01) brush.x = 0.0;
    if (abs(brush.y) < 0.01) brush.y = 0.0;
    if (abs(brush.z) < 0.01) brush.z = 0.0;
  #endif

  #if ENABLE_CIRCULAR_BRUSH
    vec2 c_uv = normalize(UV * vec2(2.0, -2.0) + vec2(-1.0, 1.0));
    vec3 brush = vec3(vec2(c_uv.y, -c_uv.x) * 0.1, 0.0);
  #endif
#endif

    vec3 lights = vec3(0, 0, 0);
    vec3 reflections = vec3(0, 0, 0);
    vec3 shared_xy_normal_map_diff = normal.x * ScreenRightDirection
                                   + normal.y * ScreenUpDirection;
    vec3 base_normal = ScreenFrontDirection * normal.z + shared_xy_normal_map_diff;
    vec3 reflection_normal = normalize(normalize(FOVNormal) * normal.z + shared_xy_normal_map_diff);

#if ENABLE_BRUSH
    vec3 brush_reflection_direction = brush.x * ScreenRightDirection
                                    + brush.y * ScreenUpDirection
                                    + brush.z * ScreenFrontDirection;
#endif

    for (int i = 0; i < LIGHTS_COUNT; i++)
    {
        lights += LightColors[i] * max(dot(base_normal, LightDirections[i]), 0.0);
#if ENABLE_BRUSH
        vec3 light_diff = LightReflectionDirections[i] - reflection_normal;
        float brush_effect = abs(dot(light_diff, brush_reflection_direction)) * 100.0;
        brush_effect = max(1.0 - brush_effect * brush_effect, 0.0);
#endif
        reflections += LightColors[i] * pow(max(dot(reflection_normal, LightReflectionDirections[i]), 0.0)
#if ENABLE_BRUSH
                * brush_effect
#endif
                , 20.0 + shininess * 10000.0); // Degrees more than 45 (90 actual degree)
                                               // will be almost invisible at 0 shininess.
                                               // cos(45) ^ 20 = 0.000976562
    }

    gl_FragColor = vec4(base_color * lights + reflections_color * reflections, 1.0);
}
