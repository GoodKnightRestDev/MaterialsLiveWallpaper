#ifndef BRUSH
  #define BRUSH 1 // For now, to test
#endif

#ifndef MAX_LIGHTS_COUNT
  #define MAX_LIGHTS_COUNT 6
#endif

precision highp float;

uniform highp vec3 ScreenFrontDirection;
uniform highp vec3 ScreenUpDirection;
uniform highp vec3 ScreenRightDirection;

uniform vec3 LightDirections[MAX_LIGHTS_COUNT];
uniform vec3 LightReflectionDirections[MAX_LIGHTS_COUNT]; // 2x closer to each other
uniform vec3 LightColors[MAX_LIGHTS_COUNT];

uniform vec2 PixelSize;

varying vec2 UV;
varying vec3 FOVNormal;
//varying vec3 FOVUp;    // May use it later
//varying vec3 FOVRight; // May use it later

void main()
{
    // example values
    vec2 normal_map_value = vec2(0, 0);
    vec3 base_color = vec3(0.5, 0.5, 0.5);
    vec3 reflections_color = vec3(0.5, 0.5, 0.5);
    float shininess = 0.0;
    // brush examples:
    vec2 c_uv = normalize(UV * 2.0 - 1.0); vec2 brush_map_value = vec2(c_uv.y, -c_uv.x) * 0.1;
    //vec2 brush_map_value = (UV - 0.5) * 2.0;
    //vec2 brush_map_value = UV;
    //vec2 brush_map_value = vec2(1, 0);
    //vec2 brush_map_value = vec2(0, 1);

    vec3 lights = vec3(0, 0, 0);
    vec3 reflections = vec3(0, 0, 0);
    vec3 normal_map_diff = normal_map_value.x * ScreenRightDirection
                         + normal_map_value.y * ScreenUpDirection;
    vec3 normal = normalize(ScreenFrontDirection + normal_map_diff);
    vec3 reflection_normal = normalize(normalize(FOVNormal) + normal_map_diff);
#if BRUSH
    vec3 brush_reflection_direction = brush_map_value.x * ScreenRightDirection
                                    + brush_map_value.y * ScreenUpDirection;
#endif

    for (int i = 0; i < MAX_LIGHTS_COUNT; i++)
    {
        lights += LightColors[i] * max(dot(normal, LightDirections[i]), 0.0);
#if BRUSH
        vec3 light_diff = LightReflectionDirections[i] - reflection_normal;
        float brush_effect = abs(dot(light_diff, brush_reflection_direction)) * 100.0;
        brush_effect = max(1.0 - brush_effect * brush_effect, 0.0);
#endif
        reflections += LightColors[i] * pow(max(dot(reflection_normal, LightReflectionDirections[i]), 0.0)
#if BRUSH
                * brush_effect
#endif
                , 20.0 + shininess * 2000.0); // Degrees more than 45 (90 actual degree)
                                              // will be almost invisible at 0 shininess.
                                              // cos(45) ^ 20 = 0.000976562
    }

    gl_FragColor = vec4(base_color * lights + reflections_color * reflections, 1.0);
}
